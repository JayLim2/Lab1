package client.gui;

import client.Main;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.MouseEvent;
import models.*;
import protocol.*;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * GUI interface controller class
 * <p>
 * It is a listener of events on the form and performs the
 * appropriate actions depending on the events generated by the form.
 *
 * @author Sergey Komarov
 * @author Rostislav Korostelev (SEARCH operation and some fixes)
 */
public class Controller {
    //Input limits
    private static final int BOOK_TITLE_CONSTRAINT = 50;
    private static final int BOOK_YEAR_MIN = 0;
    private static final int BOOK_YEAR_MAX = 2017;
    private static final int BOOK_PUBLISHER_CONSTRAINT = 35;
    private static final int BOOK_BRIEF_CONSTRAINT = 280;
    private static final int AUTHOR_NAME_CONSTRAINT = 50;
    private ClientInterface clientInterface;

    String authorName;
    String title;
    String publishYear;
    String brief;
    String publisher;

    //Books and authors tables
    @FXML
    private TableView booksTable;
    @FXML
    private TableView authorsTable;
    @FXML
    private TableColumn<BookRecord, Integer> bookIdCol;
    @FXML
    private TableColumn<BookRecord, String> bookTitleCol;
    @FXML
    private TableColumn<BookRecord, Author> bookAuthorNameCol;
    @FXML
    private TableColumn<BookRecord, Integer> bookYearCol;
    @FXML
    private TableColumn<BookRecord, String> bookPublisherCol;
    @FXML
    private TableColumn<BookRecord, String> bookBriefCol;
    @FXML
    private TableColumn<AuthorRecord, Integer> authorIdCol;
    @FXML
    private TableColumn<AuthorRecord, String> authorNameCol;
    @FXML
    private TableColumn<AuthorRecord, Integer> authorBooksCountCol;

    //Lists of tables records
    private ObservableList<BookRecord> bookRecords;
    private ObservableList<AuthorRecord> authorRecords;

    //Book input form
    @FXML
    private TextField bookIdInp;
    @FXML
    private TextField bookTitleInp;
    @FXML
    private ComboBox<Author> bookAuthorInp;
    @FXML
    private TextField bookYearInp;
    @FXML
    private TextField bookPublisherInp;
    @FXML
    private TextArea bookBriefInp;

    //Author input form
    @FXML
    private TextField authorIdInp;
    @FXML
    private TextField authorNameInp;

    //Selectors
    @FXML
    private ToggleGroup group1;
    @FXML
    private ToggleGroup group2;
    @FXML
    private RadioButton selectBook;
    @FXML
    private RadioButton selectAuthor;
    @FXML
    private RadioButton selectAddOperation;
    @FXML
    private RadioButton selectEditOperation;
    @FXML
    private RadioButton selectDelOperation;
    @FXML
    private RadioButton selectSearchOperation;
    @FXML
    private TextField anyAuthorTextField;

    //Buttons
    @FXML
    private Button runOperationBtn;
    @FXML
    private Button clearAllBtn;

    //Comparators
    private Comparator<BookRecord> bookComparator;
    private Comparator<AuthorRecord> authorComparator;

    /**
     * Class of books table records
     */
    public class BookRecord {
        private int id;
        private String title;
        private Author author;
        private int year;
        private String publisher;
        private String brief;

        public BookRecord(int id, String title, Author author, int year, String publisher, String brief) {
            this.id = id;
            this.title = title;
            this.author = author;
            this.year = year;
            this.publisher = publisher;
            this.brief = brief;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public Author getAuthor() {
            return author;
        }

        public void setAuthor(Author author) {
            this.author = author;
        }

        public int getYear() {
            return year;
        }

        public void setYear(int year) {
            this.year = year;
        }

        public String getPublisher() {
            return publisher;
        }

        public void setPublisher(String publisher) {
            this.publisher = publisher;
        }

        public String getBrief() {
            return brief;
        }

        public void setBrief(String brief) {
            this.brief = brief;
        }
    }

    /**
     * Class of authors table records
     */
    public class AuthorRecord {
        private int id;
        private String name;
        private int booksCount;

        public AuthorRecord(int id, String name, int booksCount) {
            this.id = id;
            this.name = name;
            this.booksCount = booksCount;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getBooksCount() {
            return booksCount;
        }

        public void setBooksCount(int booksCount) {
            this.booksCount = booksCount;
        }
    }

    /**
     * Initializing form and client before start work
     */
    public void initialize() {
        try {
            Socket clientSocket = new Socket(InetAddress.getLocalHost(), 4444);
            OutputStream out = clientSocket.getOutputStream();
            InputStream in = clientSocket.getInputStream();

            JAXBContext contextCommands = JAXBContext.newInstance(CommandPacket.class, ViewBooksPacket.class, AddBookPacket.class, SetBookPacket.class, RemoveBookPacket.class, AddAuthorPacket.class, SetAuthorPacket.class, RemoveAuthorPacket.class, SearchPacket.class);
            Marshaller commandMarshaller = contextCommands.createMarshaller();
            XMLInputFactory xmi = XMLInputFactory.newFactory();

            //Создание объекта вспомогательного класса, созданного только для общения с сервером
            clientInterface = new ClientInterface(clientSocket, out, in, commandMarshaller, contextCommands, xmi);

            updateAuthorsCombobox();
        } catch (UnknownHostException e) {
            System.out.println("Неизвестный хост.");
        } catch (IOException e) {
            System.out.println("Ошибка механизма ввода-вывода.");
            e.printStackTrace();
        } catch (JAXBException e) {
            System.out.println("Ошибка XML-сериализации.");
            e.printStackTrace();
        } catch (XMLStreamException e) {
            System.out.println("Ошибка потока XML.");
            e.printStackTrace();
        }

        //================================================
        group1 = new ToggleGroup();
        group2 = new ToggleGroup();
        selectBook.setToggleGroup(group1);
        selectAuthor.setToggleGroup(group1);
        selectAddOperation.setToggleGroup(group2);
        selectEditOperation.setToggleGroup(group2);
        selectDelOperation.setToggleGroup(group2);
        selectSearchOperation.setToggleGroup(group2);

        bookRecords = FXCollections.observableArrayList();
        authorRecords = FXCollections.observableArrayList();

        bookIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        bookTitleCol.setCellValueFactory(new PropertyValueFactory<>("title"));
        bookAuthorNameCol.setCellValueFactory(new PropertyValueFactory<>("author"));
        bookYearCol.setCellValueFactory(new PropertyValueFactory<>("year"));
        bookPublisherCol.setCellValueFactory(new PropertyValueFactory<>("publisher"));
        bookBriefCol.setCellValueFactory(new PropertyValueFactory<>("brief"));

        authorIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        authorNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        authorBooksCountCol.setCellValueFactory(new PropertyValueFactory<>("booksCount"));

        booksTable.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY);

        bookComparator = new BookComparator();
        authorComparator = new AuthorComparator();

        //=================================
    }

    /**
     * Handling the selection of a row in a table.
     * When you select a row in the table,
     * the information from it will import into the input fields on the form.
     *
     * @param event The event generated by the click on row in any table
     */
    @FXML
    private void handleRowSelect(MouseEvent event) {
        Node node = ((Node) event.getTarget()).getParent();
        TableRow row;
        if (node instanceof TableRow) {
            row = (TableRow) node;
        } else {
            // clicking on text part
            row = null;
            Parent parent = node.getParent();
            if (parent instanceof TableRow) {
                row = (TableRow) node.getParent();
            }
        }

        //Обработка выбранной записи
        if (row != null) {
            Object item = row.getItem();
            if (item instanceof BookRecord) {
                BookRecord record = (BookRecord) row.getItem();
                if (record != null) {
                    bookIdInp.setText(Integer.toString(record.id));
                    bookTitleInp.setText(record.title);
                    bookBriefInp.setText(record.brief);
                    bookPublisherInp.setText(record.publisher);
                    bookYearInp.setText(Integer.toString(record.year));
                    bookAuthorInp.getSelectionModel().select(record.author);
                }
            }

            if (item instanceof AuthorRecord) {
                AuthorRecord record = (AuthorRecord) row.getItem();
                if (record != null) {
                    authorIdInp.setText(Integer.toString(record.id));
                    authorNameInp.setText(record.name);
                }
            }
        }
    }

    /**
     * Updates the authors list on the form
     *
     * @throws JAXBException by ClientInterface
     * @throws XMLStreamException by ClientInterface
     */
    private void updateAuthorsCombobox() throws JAXBException, XMLStreamException {
        AuthorsContainer authorsContainer = clientInterface.viewAuthors();
        ObservableList<Author> authors = FXCollections.observableArrayList();
        authors.addAll(authorsContainer.getAuthors());
        bookAuthorInp.setItems(authors);
    }

    /**
     * The main method for starting an operation is according to the flags and fields that are filled.
     *
     * @param event The event generated by the click on RUN OPERATION button on the form
     * @throws JAXBException by ClientInterface
     */
    public void runModification(ActionEvent event) throws JAXBException {
        Commands currentCommand = null;
        if (selectBook.isSelected()) {
            if (selectAddOperation.isSelected()) {
                currentCommand = Commands.ADD_BOOK;
            }
            if (selectEditOperation.isSelected()) {
                currentCommand = Commands.SET_BOOK;
            }
            if (selectDelOperation.isSelected()) {
                currentCommand = Commands.REMOVE_BOOK;
            }
            if (selectSearchOperation.isSelected()) {
                currentCommand = Commands.SEARCH;
            }
        } else if (selectAuthor.isSelected()) {
            if (selectAddOperation.isSelected()) {
                currentCommand = Commands.ADD_AUTHOR;
            }
            if (selectEditOperation.isSelected()) {
                currentCommand = Commands.SET_AUTHOR;
            }
            if (selectDelOperation.isSelected()) {
                currentCommand = Commands.REMOVE_AUTHOR;
            }
        }

        if (currentCommand == null)
            return;

        //Считывание информации
        Book book = null;
        Author author = null;
        if (currentCommand != Commands.REMOVE_BOOK && currentCommand != Commands.REMOVE_AUTHOR && currentCommand != Commands.SEARCH) {
            if (selectBook.isSelected()) {
                book = getBookInfo();
            }
            if (selectAuthor.isSelected()) {
                author = getAuthorInfo();
            }
        }

        System.out.println(currentCommand);

        try {
            switch (currentCommand) {
                case ADD_BOOK: {
                    if (book != null) {
                        clientInterface.addBook(book, book.getAuthor());
                        clearBookForm();
                    }
                }
                break;
                case SET_BOOK: {
                    if (book != null) {
                        int bookId = -1;
                        try {
                            bookId = Integer.parseInt(bookIdInp.getText());
                        } catch (Exception e) {
                            new Alert(Alert.AlertType.ERROR, "Book ID must be a number.").show();
                        }
                        if (bookId != -1) {
                            clientInterface.editBook(bookId, book);
                        }
                    }
                }
                break;
                case REMOVE_BOOK: {
                    int id = -1;
                    try {
                        id = Integer.parseInt(bookIdInp.getText());
                    } catch (Exception ex) {
                        new Alert(Alert.AlertType.ERROR, "Book ID must be a number.").show();
                    }
                    if (id != -1) {
                        clientInterface.deleteBook(id);
                    }
                }
                break;
                case ADD_AUTHOR: {
                    if (author != null) {
                        clientInterface.addAuthor(author.getName());
                        clearAuthorForm();
                    }
                }
                break;
                case SET_AUTHOR: {
                    if (author != null) {
                        int authorId = -1;
                        try {
                            authorId = Integer.parseInt(authorIdInp.getText());
                        } catch (Exception e) {
                            new Alert(Alert.AlertType.ERROR, "Author ID must be a number.").show();
                        }

                        if (authorId != -1) {
                            clientInterface.editAuthor(authorId, author.getName());
                        }
                    }
                }
                break;
                case REMOVE_AUTHOR: {
                    int id = -1;
                    try {
                        id = Integer.parseInt(authorIdInp.getText());
                    } catch (Exception ex) {
                        new Alert(Alert.AlertType.ERROR, "Author ID must be a number.").show();
                    }
                    if (id != -1) {
                        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, "If you delete the author, all his books will also be deleted. Continue?", ButtonType.YES, ButtonType.NO);
                        final int tmp_id = id;

                        alert.showAndWait().ifPresent(buttonType -> {
                            if (buttonType.getButtonData() == ButtonBar.ButtonData.YES) {
                                try {
                                    clientInterface.deleteAuthor(tmp_id);
                                } catch (JAXBException ex) {
                                } catch (XMLStreamException ex) {
                                }
                            }

                            if (buttonType.getButtonData() == ButtonBar.ButtonData.NO) {
                                System.out.println("REMOVE AUTHOR has been cancelled.");
                            }
                        });
                    }
                }
                break;

                case SEARCH: {
                    //fixed 05.02
                    //можно выбрать из списка или ввести ручками; если поле ввода не пустое - ищет по нему
                    if (bookAuthorInp.getSelectionModel().getSelectedIndex() != -1 && anyAuthorTextField.getText().isEmpty()) {
                        authorName = bookAuthorInp.getSelectionModel().getSelectedItem().getName();
                    } else {
                        if (anyAuthorTextField.getText().isEmpty()) {
                            authorName = "*";
                        } else {
                            authorName = "*".concat(anyAuthorTextField.getText()).concat("*");
                        }
                    }

                    if (bookTitleInp.getText().isEmpty()) {
                        title = "*";
                    } else {
                        title = "*".concat(bookTitleInp.getText()).concat("*");
                    }

                    if (bookYearInp.getText().isEmpty()) {
                        publishYear = "*";
                    } else {
                        publishYear = "*".concat(bookYearInp.getText()).concat("*");
                    }
                    if (bookBriefInp.getText().isEmpty()) {
                        brief = "*";
                    } else {
                        brief = "*".concat(bookBriefInp.getText()).concat("*");
                    }
                    if (bookPublisherInp.getText().isEmpty()) {
                        publisher = "*";
                    } else {
                        publisher = "*".concat(bookPublisherInp.getText()).concat("*");
                    }
                    /*String authorName = anyAuthorTextField.getText();
                    String title = bookTitleInp.getText();
                    String publishYear = bookYearInp.getText();
                    String brief = bookBriefInp.getText();
                    String publisher = bookPublisherInp.getText();*/

                    try {
                        bookRecords.clear();
                        authorRecords.clear();

                        AuthorsContainer authorsContainer = clientInterface.searchBook(title, authorName, publishYear, brief, publisher);
                        if (authorsContainer != null) {
                            List<Author> authors1 = authorsContainer.getAuthors();
                            for (Author author1 : authors1) {
                                authorRecords.add(new AuthorRecord(author1.getId(), author1.getName(), author1.getBooks().size()));
                                List<Book> books1 = author1.getBooks();
                                for (Book book1 : books1) {
                                    bookRecords.add(new BookRecord(book1.getId(), book1.getTitle(), author1, book1.getPublishYear(), book1.getPublisher(), book1.getBrief()));
                                }
                            }

                            System.out.println("The book list has been received.\n");
                        } else {
                            System.out.println("The book list is NOT received.");
                        }

                        updateAuthorsCombobox();

                        booksTable.setItems(bookRecords);
                        authorsTable.setItems(authorRecords);

                        bookRecords.sort(bookComparator);
                        authorRecords.sort(authorComparator);

                        enableModificationForm();
                    } catch (XMLStreamException ex) {
                        Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                    } catch (JAXBException ex) {
                        System.out.println("XML Serialization Error.");
                        ex.printStackTrace();
                    }
                }
                break;
            }
            if (currentCommand != Commands.SEARCH) {
                runViewBooks(event);
                runViewAuthors(event);
            }
        } catch (XMLStreamException ex) {
            System.out.println("server offline");
        }
    }

    /**
     * Creates a new BOOK by the parameters received from the form
     *
     * @return new Book object if all inputs are correct OR null if thrown exceptions.
     */
    private Book getBookInfo() {
        Book book = null;
        try {
            Author bookAuthor = bookAuthorInp.getValue();
            if (bookAuthor == null) {
                throw new NoAuthorException();
            }
            String title = bookTitleInp.getText();
            int year = Integer.parseInt(bookYearInp.getText());
            String publisher = bookPublisherInp.getText();
            String brief = bookBriefInp.getText();

            if (title.isEmpty() || publisher.isEmpty() || brief.isEmpty()) {
                throw new EmptyFieldException();
            }

            if (title.length() <= BOOK_TITLE_CONSTRAINT &&
                    publisher.length() <= BOOK_PUBLISHER_CONSTRAINT &&
                    (year >= BOOK_YEAR_MIN && year <= BOOK_YEAR_MAX) &&
                    brief.length() <= BOOK_BRIEF_CONSTRAINT) {
                book = new Book(title, bookAuthor, year, publisher, brief);
            } else {
                String errorMsg = "";
                if (title.length() > BOOK_TITLE_CONSTRAINT)
                    errorMsg += "* The title of the book exceeds the allowed number of characters.\n";
                if (publisher.length() > BOOK_PUBLISHER_CONSTRAINT)
                    errorMsg += "* The publisher name exceeds the  allowed number of characters.\n";
                if (brief.length() > BOOK_BRIEF_CONSTRAINT)
                    errorMsg += "* The length of the short description exceeds " + BOOK_BRIEF_CONSTRAINT + " characters.\n";
                new Alert(Alert.AlertType.ERROR, errorMsg).show();
            }
        } catch (YearOutOfBoundsException ex) {
            new Alert(Alert.AlertType.ERROR, "The year of publication must be in the range of " + BOOK_YEAR_MIN + " to " + BOOK_YEAR_MAX).show();
        } catch (NoAuthorException ex) {
            new Alert(Alert.AlertType.ERROR, "You can not add / edit a book without the author.").show();
        } catch (EmptyFieldException ex) {
            new Alert(Alert.AlertType.ERROR, "Some fields are empty").show();
        } catch (Exception ex) {
            new Alert(Alert.AlertType.ERROR, "The year of publication must be a number").show();
        }
        return book;
    }

    /**
     * Creates new AUTHOR by the parameters received from the form
     *
     * @return new Author object if all inputs are correct  OR null if thrown exception
     */
    private Author getAuthorInfo() {
        Author author = null;
        try {
            String authorName = authorNameInp.getText();
            if (!authorName.isEmpty() && authorName.length() <= AUTHOR_NAME_CONSTRAINT)
                author = new Author(authorName);
            else
                new Alert(Alert.AlertType.ERROR, "* Author name length exceeds the allowed number of characters OR empty.").show();
        } catch (Exception ex) {

        }
        return author;
    }

    /**
     * The handler for the event of getting and printing a list of BOOKS to the form.
     *
     * @param event The event generated by the action on the form
     */
    public void runViewBooks(ActionEvent event) {
        try {
            bookRecords.clear();
            authorRecords.clear();

            AuthorsContainer authorsContainer = clientInterface.viewBooks();
            if (authorsContainer != null) {
                List<Author> authors = authorsContainer.getAuthors();
                for (Author author : authors) {
                    authorRecords.add(new AuthorRecord(author.getId(), author.getName(), author.getBooks().size()));
                    List<Book> books = author.getBooks();
                    for (Book book : books) {
                        bookRecords.add(new BookRecord(book.getId(), book.getTitle(), author, book.getPublishYear(), book.getPublisher(), book.getBrief()));
                    }
                }
            }

            bookRecords.sort(bookComparator);
            authorRecords.sort(authorComparator);

            updateAuthorsCombobox();

            booksTable.setItems(bookRecords);
            authorsTable.setItems(authorRecords);

            enableModificationForm();
        } catch (XMLStreamException ex) {
            System.out.println("server offline");
        } catch (JAXBException ex) {
            System.out.println("marshalling error");
        }
    }

    /**
     * Enable all input fields and main buttons
     */
    private void enableModificationForm() {
        selectBook.setDisable(false);
        selectAuthor.setDisable(false);
        selectAddOperation.setDisable(false);
        selectEditOperation.setDisable(false);
        selectDelOperation.setDisable(false);
        selectSearchOperation.setVisible(true);
        if ((selectAddOperation.isSelected() || selectEditOperation.isSelected()) && selectBook.isSelected())
            enableBookMainInfo();
        runOperationBtn.setDisable(false);
        clearAllBtn.setDisable(false);
    }

    //Применится потом: в случае возникновения ошибки чтения с сервера (из файла), форма блокируется

    /**
     * Disable all input fields and main buttons
     */
    private void disableModificationForm() {
        selectBook.setDisable(true);
        selectAuthor.setDisable(true);
        selectAddOperation.setDisable(true);
        selectEditOperation.setDisable(true);
        selectDelOperation.setDisable(true);
        selectSearchOperation.setVisible(false);
        if ((selectAddOperation.isSelected() || selectEditOperation.isSelected()) && selectBook.isSelected())
            disableBookMainInfo();
        runOperationBtn.setDisable(true);
        clearAllBtn.setDisable(true);
    }

    /**
     * The handler for the event of getting and printing a list of AUTHORS to the form.
     * Calls runViewBooks
     *
     * @param event The event generated by the action on the form
     */
    public void runViewAuthors(ActionEvent event) {
        runViewBooks(event);
    }

    /**
     * Selecting Book type of operand.
     *
     * @param event The event generated by the click on BOOK radiobutton on the form
     */
    public void selectBook(ActionEvent event) {
        //Отключение формы с автором
        selectSearchOperation.setVisible(true);
        authorNameInp.setDisable(true);

        if (selectDelOperation.isSelected() || selectEditOperation.isSelected()) {
            anyAuthorTextField.setVisible(false);
        }

        if (!selectDelOperation.isSelected()) {
            enableBookMainInfo();
            anyAuthorTextField.setVisible(false);
        } else {
            disableBookMainInfo();
        }

        if (selectSearchOperation.isSelected()) {
            anyAuthorTextField.setVisible(true);
        } else {
            anyAuthorTextField.setVisible(false);
        }

        System.out.println("Operand type Book is selected.");
    }

    /**
     * Selecting Author type of operand.
     *
     * @param event The event generated by the click on AUTHOR radiobutton on the form
     */
    public void selectAuthor(ActionEvent event) {
        if (selectSearchOperation.isSelected()) {
            selectAddOperation.setSelected(true);
        }

        if (!selectDelOperation.isSelected())
            authorNameInp.setDisable(false);
        else
            authorNameInp.setDisable(true);

        //Отключение формы с книгой
        disableBookMainInfo();
        selectSearchOperation.setVisible(false);
        anyAuthorTextField.setVisible(false);

        System.out.println("Operand type Author is selected.");
    }

    /**
     * Enable all input fields in form of modification book.
     */
    private void enableBookMainInfo() {
        bookTitleInp.setDisable(false);
        bookAuthorInp.setDisable(false);
        bookYearInp.setDisable(false);
        bookPublisherInp.setDisable(false);
        bookBriefInp.setDisable(false);
    }

    /**
     * Disable all input fields in form of modification book.
     */
    private void disableBookMainInfo() {
        bookTitleInp.setDisable(true);
        bookAuthorInp.setDisable(true);
        bookYearInp.setDisable(true);
        bookPublisherInp.setDisable(true);
        bookBriefInp.setDisable(true);
    }

    /**
     * Disable all input fields
     */
    private void disableAllInfo() {
        disableBookMainInfo();
        authorNameInp.setDisable(true);
    }

    /**
     * Selecting ADD type of operation
     *
     * @param event The event generated by the click on ADD radiobutton on the form
     */
    public void selectAddOperation(ActionEvent event) {
        if (selectBook.isSelected()) {
            enableBookMainInfo();
        } else if (selectAuthor.isSelected()) {
            authorNameInp.setDisable(false);
        }

        System.out.println("Operation Add is selected.");
    }

    /**
     * Selecting EDIT (SET) type of operation
     *
     * @param event The event generated by the click on EDIT radiobutton on the form
     */
    public void selectEditOperation(ActionEvent event) {
        if (selectBook.isSelected()) {
            enableBookMainInfo();
        } else if (selectAuthor.isSelected()) {
            authorNameInp.setDisable(false);
        }

        System.out.println("Operation Edit is selected.");
    }

    /**
     * Selecting DELETE (REMOVE) type of operation
     *
     * @param event The event generated by the click on DELETE radiobutton on the form
     */
    public void selectDelOperation(ActionEvent event) {
        if (selectBook.isSelected()) {
            disableBookMainInfo();
        } else if (selectAuthor.isSelected()) {
            authorNameInp.setDisable(true);
        }

        System.out.println("Operation Delete is selected.");
    }

    /**
     * Selecting SEARCH type of operation
     *
     * @param event The event generated by the click on SEARCH radiobutton on the form
     */
    //todo select in controller
    public void selectSearchOperation(ActionEvent event) {
        if (selectBook.isSelected()) {
            enableBookMainInfo();
            anyAuthorTextField.setVisible(true);
        }/* else if (selectAuthor.isSelected()) {
            new Alert(Alert.AlertType.ERROR, "Search is possible only among books.").show();
            anyAuthorTextField.clear();
            anyAuthorTextField.setVisible(false);
            //authorNameInp.setDisable(true);
        }*/

        System.out.println("Operation Search is selected.");
    }

    /**
     * Clears all input fields.
     *
     * @param event The event generated by the click on CLEAR BUTTON on the form
     */
    public void clearAll(ActionEvent event) {
        clearBookForm();
        clearAuthorForm();
    }

    /**
     * Clears all input fields in book input form.
     */
    private void clearBookForm() {
        bookIdInp.clear();
        bookTitleInp.clear();
        bookPublisherInp.clear();
        bookYearInp.clear();
        bookBriefInp.clear();
        bookAuthorInp.getSelectionModel().select(-1);
    }

    /**
     * Clears all input fields in author input form.
     */
    private void clearAuthorForm() {
        authorIdInp.clear();
        authorNameInp.clear();
    }

    /**
     * Help with book author input when adding/editing or searching book.
     *
     * @param event The event generated by the click on HELP LABEL on the form
     */
    public void helpWithAuthorAction(MouseEvent event) {
        String message = "";
        message += "When adding/editing book:\n";
        message += "\tTo specify the author when adding / editing a book, select the one you want from the list. You can not add a book without the author.\n";
        message += "\nWhen searching book:\n";
        message += "\tTo specify the author when searching for a book, you must either select from the list (the adjacent input field must be EMPTY), OR enter in part or all the author's name in the input field.\n\tIf the input field is NOT EMPTY, then the search is carried out by its contents.\n";

        new Alert(Alert.AlertType.INFORMATION, message).show();
    }
}
